C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE UART_COMMAND
OBJECT MODULE PLACED IN .\Output\UART_Command.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\UART_Command.c LARGE OPTIMIZE(7,SPEED) BROWSE INCDIR(..\..\..\..\Libr
                    -ary\Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG OBJECTEXTEND PRINT(.\LST\UART_Command.lst) TABS(2) OBJECT(.\
                    -Output\UART_Command.obj)

line level    source

   1          
   2          #include "UART_Command.h"
   3          
   4          
   5          #define UARTCMD_WILDCARD            (0xFD)
   6          
   7          //CMD ack define
   8          #define UARTCMD_ACK             (0xB0)
   9          #define UARTCMD_NOT_SUPPORT         (0xB1)
  10          #define UARTCMD_ERROR_CHECKSUM        (0xB2)
  11          #define UARTCMD_NACK              (0xB3)
  12          #define UARTCMD_BAD_FORMAT          (0xB4)
  13          
  14          //UART CMD variable
  15          uint8_t   u8UartRxCnt = 0;
  16          uint8_t   u8SetProcessPkt = 0;
  17          
  18          //  CMD structure 
  19          //  header + function code + length + data + checksum + tailer
  20          
  21          //  UART CMD format
  22          //  0     1     2     3     4     5     6     7   8
  23          //  HEADER  FUNC  LEN   D1    D2    D3    D4    CHK   TAILER
  24          
  25          //  response 
  26          //  HEAD    B0    00    00    00    00    00    50    TAILER //command send in ok and process
  27          //  HEAD    B1    00    00    00    00    00    4F    TAILER //command not correct or no process
  28          
  29          
  30          // TODO: Step #1 , add function code index
  31          //CMD function code table index define
  32          typedef enum
  33          {
  34            UARTCMD_FUNCTION01_SET = 0x0A,
  35            UARTCMD_FUNCTION02_GET = 0x0B,  
  36            UARTCMD_FUNCTION03_GET = 0x0C,
  37            UARTCMD_FUNCTION04_GET = 0x0D,
  38            
  39            UARTCMD_FUNCTION05_SET = 0x3E,
  40            UARTCMD_FUNCTION06_GET = 0x3F,
  41            
  42            UARTCMD_FUNCTION_MAX,
  43          }UARTCMD_FUNCTION_CODE; //customize
  44          
  45          typedef enum
  46          {
  47            RESULT_ACK_OK = 0,
  48            RESULT_ACK_NOT_SUPPORTED, 
  49            RESULT_ACK_ERROR_CHECKSUM,
  50            RESULT_ACK_NACK, 
  51            RESULT_ACK_BAD_FORMAT, 
  52            
  53            RESULT_MAX,
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 2   

  54          } UARTCMD_RESULT_t;
  55          
  56          typedef struct {
  57            uint8_t header;
  58            uint8_t function;
  59            uint8_t length;
  60            uint8_t Data[UARTCMD_DATA_LEN];
  61            uint8_t checksum;
  62            uint8_t tailer;
  63          }UARTCMD_BUF_t;
  64          
  65          typedef struct
  66          {
  67            UARTCMD_FUNCTION_CODE cmd_code;
  68            uint8_t length;
  69            uint8_t data_template;
  70            UARTCMD_RESULT_t (*handler) (UARTCMD_BUF_t *cmd);
  71          } UARTCMD_TEMPLATE_t;
  72          
  73          #define UARTCMD_CHKSUM_OFFSET         (sizeof(UARTCMD_BUF_t)-1)
  74          #define UARTCMD_LENGTH              (sizeof(UARTCMD_BUF_t))
  75          
  76          uint8_t           aui1_cmd_buf[UARTCMD_LENGTH];
  77          UARTCMD_BUF_t     UartCommand;
  78          
  79          static void _UartCmdParser_CmdFormat(uint8_t length,uint8_t data1,uint8_t data2,uint8_t data3,uint8_t data
             -4);
  80          
  81          
  82          // TODO: Step #2 , modify function to expect behavior , set data by TX or get data and return to TX
  83          //  UART CMD format
  84          //  0     1     2     3     4     5     6     7   8
  85          //  HEADER  0x0A  4     D0    D1    D2    D3    CHK   TAILER
  86          
  87          /*
  88            Example 1: 
  89            TX send data 0x11 , 0x22 , 0x33 , 0x44 , with function code 0x0A
  90            \34\0A\04\11\22\33\44\48\81
  91          
  92            after RX receive , if confirm checksum correct , will feedback UARTCMD_ACK (B0)
  93            34 B0 00 00 00 00 00 50 81  
  94          
  95            Example 2:  if use wrong checksum , 
  96            \34\0a\04\11\22\33\44\49\81
  97          
  98             will feedback UARTCMD_ERROR_CHECKSUM (B2)
  99            34 B2 00 45 53 55 4D 14 81
 100          
 101          
 102            Example 3:  if use wrong function code with correct checksum , 
 103            \34\28\04\11\22\33\44\2A\81
 104          
 105             will feedback UARTCMD_NACK (B3)
 106            34 B3 00 4E 41 43 4B 30 81
 107          */
 108           
 109          UARTCMD_RESULT_t CustomUartCmdHandler_Function01_Set(UARTCMD_BUF_t *cmd)
 110          {
 111   1        uint8_t temp = 0; //example , put command data into a variable
 112   1      
 113   1        _UartCmdParser_CmdFormat(0x00,0x00,0x00,0x00,0x00);
 114   1      
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 3   

 115   1        temp = cmd->Data[0];  //for this example , use temp to store data
 116   1        temp = cmd->Data[1];
 117   1        temp = cmd->Data[2];
 118   1        temp = cmd->Data[3];
 119   1        
 120   1        return RESULT_ACK_OK;
 121   1      }
 122          
 123          /*
 124            Example : 
 125            TX request data with function code 0x0B , 
 126            \34\0B\01\00\00\00\00\F4\81
 127          
 128            after RX receive , if confirm checksum correct , will feedback UARTCMD_ACK (B0) with 1 byte data
 129            34 B0 01 96 00 00 00 B9 81  
 130          */
 131          UARTCMD_RESULT_t CustomUartCmdHandler_Function02_Get(UARTCMD_BUF_t *cmd)
 132          {
 133   1        uint8_t Data = 0x96;    //example , set 1 byte data out
 134   1      
 135   1        _UartCmdParser_CmdFormat(UARTCMD_1_BYTE_DATA,Data,0x00,0x00,0x00);
 136   1      
 137   1        (void) cmd;
*** WARNING C275 IN LINE 137 OF ..\UART_Command.c: expression with possibly no effect
 138   1        
 139   1        return RESULT_ACK_OK;
 140   1      }
 141          
 142          /*
 143            Example : 
 144            TX request data with function code 0x0C , 
 145            \34\0C\02\00\00\00\00\F2\81
 146          
 147            after RX receive , if confirm checksum correct , will feedback UARTCMD_ACK (B0) with 2 byte data
 148            34 B0 02 12 34 00 00 08 81  
 149          */
 150          UARTCMD_RESULT_t CustomUartCmdHandler_Function03_Get(UARTCMD_BUF_t *cmd)
 151          {
 152   1        uint16_t Data = 0x1234; //example , set 2 byte bit data out
 153   1      
 154   1        _UartCmdParser_CmdFormat(UARTCMD_2_BYTE_DATA,HIBYTE(Data),LOBYTE(Data),0x00,0x00);
 155   1      
 156   1        (void) cmd;
*** WARNING C275 IN LINE 156 OF ..\UART_Command.c: expression with possibly no effect
 157   1        
 158   1        return RESULT_ACK_OK;
 159   1      } 
 160          
 161          /*
 162            Example : 
 163            TX request data with function code 0x0D , 
 164            \34\0D\04\00\00\00\00\EF\81
 165          
 166            after RX receive , if confirm checksum correct , will feedback UARTCMD_ACK (B0) with 4 byte data
 167            34 B0 04 55 66 32 31 2E 81  
 168          */
 169          UARTCMD_RESULT_t CustomUartCmdHandler_Function04_Get(UARTCMD_BUF_t *cmd)
 170          {
 171   1        uint16_t Data1 = 0x5566;  //example , set 4 byte bit data out
 172   1        uint16_t Data2 = 0x3231;
 173   1        
 174   1        _UartCmdParser_CmdFormat(UARTCMD_4_BYTE_DATA,HIBYTE(Data1),LOBYTE(Data1),HIBYTE(Data2),LOBYTE(Data2));
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 4   

 175   1      
 176   1        (void) cmd;
*** WARNING C275 IN LINE 176 OF ..\UART_Command.c: expression with possibly no effect
 177   1        
 178   1        return RESULT_ACK_OK;
 179   1      } 
 180          
 181          /*
 182            Example : 
 183            TX send data 0x13 , 0x57 , 0x90 with function code 0x3E
 184            \34\3E\03\13\57\90\00\C5\81
 185          
 186            after RX receive , if confirm checksum correct , will feedback UARTCMD_ACK (B0)
 187            34 B0 00 00 00 00 00 50 81  
 188          */
 189          UARTCMD_RESULT_t CustomUartCmdHandler_Function05_Set(UARTCMD_BUF_t *cmd)
 190          {
 191   1        uint8_t temp = 0; //example , put command data into a your application data address
 192   1      
 193   1        _UartCmdParser_CmdFormat(0x00,0x00,0x00,0x00,0x00);
 194   1      
 195   1        temp = cmd->Data[0];  //for this example , use temp to store data
 196   1        temp = cmd->Data[1];
 197   1        temp = cmd->Data[2];
 198   1        temp = cmd->Data[3];
 199   1        
 200   1        return RESULT_ACK_OK;
 201   1      } 
 202          
 203          /*
 204            Example : 
 205            TX request data with function code 0x3F , 
 206            \34\3F\03\00\00\00\00\BE\81
 207          
 208            after RX receive , if confirm checksum correct , will feedback UARTCMD_ACK (B0) with 3 byte data
 209            34 B0 03 13 57 00 90 53 81  
 210          */
 211          
 212          UARTCMD_RESULT_t CustomUartCmdHandler_Function06_Get(UARTCMD_BUF_t *cmd)
 213          {
 214   1        uint16_t Data1 = 0x1357;  //example , set 3 byte bit data out
 215   1        uint8_t Data2 = 0x90;
 216   1        
 217   1        _UartCmdParser_CmdFormat(UARTCMD_3_BYTE_DATA,HIBYTE(Data1),LOBYTE(Data1),HIBYTE(Data2),LOBYTE(Data2));
 218   1      
 219   1        (void) cmd;
*** WARNING C275 IN LINE 219 OF ..\UART_Command.c: expression with possibly no effect
 220   1        
 221   1        return RESULT_ACK_OK;
 222   1      } 
 223          
 224          // TODO: Step #3 , register function code and function to array
 225          UARTCMD_TEMPLATE_t _UartCmdParser_Array[] = 
 226          {
 227            {UARTCMD_FUNCTION01_SET ,UARTCMD_4_BYTE_DATA, UARTCMD_WILDCARD, CustomUartCmdHandler_Function01_Set},
 228            {UARTCMD_FUNCTION02_GET ,UARTCMD_1_BYTE_DATA, UARTCMD_WILDCARD, CustomUartCmdHandler_Function02_Get},
 229            {UARTCMD_FUNCTION03_GET ,UARTCMD_2_BYTE_DATA, UARTCMD_WILDCARD, CustomUartCmdHandler_Function03_Get},
 230            {UARTCMD_FUNCTION04_GET ,UARTCMD_4_BYTE_DATA, UARTCMD_WILDCARD, CustomUartCmdHandler_Function04_Get},
 231          
 232            {UARTCMD_FUNCTION05_SET ,UARTCMD_3_BYTE_DATA, UARTCMD_WILDCARD, CustomUartCmdHandler_Function05_Set},
 233            {UARTCMD_FUNCTION06_GET ,UARTCMD_3_BYTE_DATA, UARTCMD_WILDCARD, CustomUartCmdHandler_Function06_Get},
 234            
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 5   

 235            {0xFF, 0x00, 0x00, NULL},  // this is the end of list marker
 236          };
 237          
 238          /*
 239            UART CMD format
 240            0     1     2     3     4     5     6     7   8
 241            HEADER  0x0A  4     D0    D1    D2    D3    CHK   TAILER
 242          
 243            CHECKSUM = 0 - (byte 1 + ... byte 6) , if UARTCMD_DATA_LEN define 4 
 244          */
 245          static uint8_t _UartCmdParser_GetChecksum(UARTCMD_BUF_t *cmd )
 246          {
 247   1          int i;
 248   1          uint8_t u8Checksum = 0;
 249   1          uint8_t* u8Ptr = (uint8_t*)cmd;
 250   1      
 251   1          for (i=1; i < UARTCMD_CHKSUM_OFFSET-1; i++)
 252   1              u8Checksum += *(u8Ptr+i);
 253   1      
 254   1          //return (0-ucChecksum);
 255   1          return (uint8_t) (0-u8Checksum);
 256   1      }
 257          
 258          static void _UartCmdParser_CmdFormat(uint8_t length,uint8_t data1,uint8_t data2,uint8_t data3,uint8_t data
             -4)
 259          {
 260   1        //Need to manual decide the cmd output data
 261   1        UartCommand.length  = length;
 262   1        UartCommand.Data[0] = data1;
 263   1        UartCommand.Data[1] = data2;
 264   1        UartCommand.Data[2] = data3;
 265   1        UartCommand.Data[3] = data4;
 266   1        
 267   1      }
 268          
 269          static void _UartCmdParser_SendFeedback(UARTCMD_RESULT_t result,UARTCMD_BUF_t *cmd)
 270          {
 271   1        UARTCMD_BUF_t rcmd;
 272   1        (void) cmd;
*** WARNING C275 IN LINE 272 OF ..\UART_Command.c: expression with possibly no effect
 273   1        
 274   1        switch( result )
 275   1        {
 276   2          case RESULT_ACK_OK:
 277   2            //buffer will depend on each function return value
 278   2            rcmd.function = UARTCMD_ACK;
 279   2            break;
 280   2      
 281   2          case RESULT_ACK_NOT_SUPPORTED:
 282   2            _UartCmdParser_CmdFormat(0x00,0x4E,0x53,0x55,0x50);//use NSUP to verify whats happen      
 283   2            rcmd.function = UARTCMD_NOT_SUPPORT;            
 284   2            break;
 285   2            
 286   2          case RESULT_ACK_ERROR_CHECKSUM:
 287   2            _UartCmdParser_CmdFormat(0x00,0x45,0x53,0x55,0x4D);//use ESUM to verify whats happen    
 288   2            rcmd.function = UARTCMD_ERROR_CHECKSUM;
 289   2            break;
 290   2      
 291   2          case RESULT_ACK_BAD_FORMAT:
 292   2            _UartCmdParser_CmdFormat(0x00,0x42,0x41,0x44,0x46);//use BADF to verify whats happen    
 293   2            rcmd.function = UARTCMD_BAD_FORMAT;
 294   2            break;
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 6   

 295   2            
 296   2          default:
 297   2            _UartCmdParser_CmdFormat(0x00,0x4E,0x41,0x43,0x4B);//use NACK to verify whats happen
 298   2            rcmd.function = UARTCMD_NACK;
 299   2            break;
 300   2        }
 301   1        
 302   1        rcmd.header = UARTCMD_HEADER;
 303   1      
 304   1        //manual clear data
 305   1        rcmd.length = UartCommand.length; 
 306   1        rcmd.Data[0]= UartCommand.Data[0]; 
 307   1        rcmd.Data[1]= UartCommand.Data[1];
 308   1        rcmd.Data[2]= UartCommand.Data[2];
 309   1        rcmd.Data[3]= UartCommand.Data[3];
 310   1        
 311   1        rcmd.checksum = _UartCmdParser_GetChecksum(&rcmd);
 312   1        rcmd.tailer = UARTCMD_TAILER;
 313   1      
 314   1        UartCmd_Send((uint8_t*)&rcmd,UARTCMD_LENGTH);
 315   1      
 316   1      }
 317          
 318          
 319          // TODO: Step #4 , add function code to set command
 320          static void _UartCmdParser_Set_cmd(UARTCMD_BUF_t *cmd)
 321          {
 322   1        UARTCMD_RESULT_t result = RESULT_ACK_OK ;
 323   1      
 324   1        switch(cmd->function)
 325   1        {
 326   2          case UARTCMD_FUNCTION01_SET:
 327   2            result = CustomUartCmdHandler_Function01_Set(cmd);
 328   2            break;
 329   2          case UARTCMD_FUNCTION02_GET:
 330   2            result = CustomUartCmdHandler_Function02_Get(cmd);
 331   2            break;      
 332   2          case UARTCMD_FUNCTION03_GET:
 333   2            result = CustomUartCmdHandler_Function03_Get(cmd);
 334   2            break;
 335   2          case UARTCMD_FUNCTION04_GET:
 336   2            result = CustomUartCmdHandler_Function04_Get(cmd);
 337   2            break;
 338   2          case UARTCMD_FUNCTION05_SET:
 339   2            result = CustomUartCmdHandler_Function05_Set(cmd);
 340   2            break;
 341   2          case UARTCMD_FUNCTION06_GET:
 342   2            result = CustomUartCmdHandler_Function06_Get(cmd);
 343   2            break;      
 344   2        }   
 345   1      
 346   1        _UartCmdParser_SendFeedback(result ,cmd); 
 347   1      }
 348          
 349          static int _UartCmdParser_FindHandlerIndex(UARTCMD_BUF_t *cmd)
 350          {
 351   1          int i;
 352   1      
 353   1          for (i=0; _UartCmdParser_Array[i].cmd_code != 0xFF; i++)
 354   1          {
 355   2              if ((cmd->header == UARTCMD_HEADER) &&
 356   2                (cmd->function == _UartCmdParser_Array[i].cmd_code) &&
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 7   

 357   2                (cmd->tailer == UARTCMD_TAILER))
 358   2          {
 359   3            #if 0 //debug
                    //UART_Send_Data(UART0 ,_UartCmdParser_Array[i].length);
                    //UART_Send_Data(UART0 ,cmd->length);     
                    //UART_Send_Data(UART0 , _UartCmdParser_Array[i].data1);  
                    //UART_Send_Data(UART0 , cmd->data[0]); 
                    #endif
 365   3            
 366   3            if ( (_UartCmdParser_Array[i].length == UARTCMD_WILDCARD && _UartCmdParser_Array[i].data_template == UA
             -RTCMD_WILDCARD) ||
 367   3              (_UartCmdParser_Array[i].length == cmd->length && _UartCmdParser_Array[i].data_template == UARTCMD_WIL
             -DCARD) ||
 368   3              (_UartCmdParser_Array[i].length == UARTCMD_WILDCARD && _UartCmdParser_Array[i].data_template == cmd->D
             -ata[0]) ||
 369   3              (_UartCmdParser_Array[i].length == cmd->length && _UartCmdParser_Array[i].data_template == cmd->Data[0
             -]) )
 370   3            {
 371   4              return i;
 372   4            }
 373   3            else
 374   3              continue;
 375   3              } //if 
 376   2          }
 377   1          return -1;  //if we reached here then we never found the entry in the table
 378   1      }
 379          
 380          static void _UartCmdParser_Parse_cmd(void)
 381          {
 382   1        UARTCMD_BUF_t*  cmd = (UARTCMD_BUF_t*)aui1_cmd_buf;
 383   1        int       nTemplateIdx = 0;
 384   1      
 385   1        /* make sure we got a good packet. */
 386   1        if ( cmd->checksum != _UartCmdParser_GetChecksum(cmd) )
 387   1        {   
 388   2          #if 0 //debug   
                  //Printf("RESULT_ACK_ERROR_CHECKSUM\n");    
                  UartCmd_Send("\r1" , sizeof("\r1"));    
                  #endif /*debug*/
 392   2          
 393   2          _UartCmdParser_SendFeedback(RESULT_ACK_ERROR_CHECKSUM, cmd);
 394   2          return;
 395   2        }
 396   1      
 397   1        /* if we can't find a match in our template, then its not good!! */
 398   1        nTemplateIdx = _UartCmdParser_FindHandlerIndex(cmd);
 399   1        if (nTemplateIdx < 0)
 400   1        {
 401   2          #if 0 //debug   
                  //Printf("RESULT_ACK_NACK\n");    
                  UartCmd_Send("\r1" , sizeof("\r1"));    
                  #endif /*debug*/
 405   2        
 406   2          _UartCmdParser_SendFeedback(RESULT_ACK_NACK, cmd);
 407   2          return;
 408   2        }
 409   1      
 410   1        /* see if handler exist */
 411   1        if ( _UartCmdParser_Array[nTemplateIdx].handler == NULL )
 412   1        {
 413   2          #if 0 //debug   
                  //Printf("RESULT_ACK_NOT_SUPPORTED\n");   
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 8   

                  UartCmd_Send("RESULT_ACK_NOT_SUPPORTED" , sizeof("RESULT_ACK_NOT_SUPPORTED"));    
                  #endif /*debug*/    
 417   2          _UartCmdParser_SendFeedback(RESULT_ACK_NOT_SUPPORTED, cmd);
 418   2          return; 
 419   2        }
 420   1      
 421   1        /* finally execute the handler */
 422   1        _UartCmdParser_Set_cmd(cmd);
 423   1      
 424   1      }
 425          
 426          // TODO: Step #5 , add UartCmdParser_Rx_Receive to UART IRQ handler
 427          void UartCmdParser_Rx_Receive(uint8_t tmp)
 428          {
 429   1        aui1_cmd_buf[u8UartRxCnt++] = tmp;
 430   1      
 431   1        //force to check buffer header/length/tail , reset counter if meet cmd format
 432   1        if(u8UartRxCnt !=0 || aui1_cmd_buf[u8UartRxCnt] == UARTCMD_HEADER)    
 433   1        {
 434   2          if ( u8UartRxCnt == UARTCMD_LENGTH )    
 435   2          {
 436   3            if ( aui1_cmd_buf[u8UartRxCnt-1] == UARTCMD_TAILER )
 437   3            {
 438   4              u8UartRxCnt = 0;
 439   4              u8SetProcessPkt = 1;
 440   4            }
 441   3            else
 442   3            {
 443   4              //bad cmd format , send not support ack     
 444   4              _UartCmdParser_SendFeedback(RESULT_ACK_BAD_FORMAT, NULL); 
 445   4              
 446   4              #if 0 //debug
                      UartCmd_Send(">>>\r\n",sizeof(">>>\r\n"));        
                      UART_Send_Data(UART0 ,  UARTCMD_LENGTH);
                      UartCmd_Send(">>>\r\n",sizeof(">>>\r\n"));
                      UartCmd_Send(aui1_cmd_buf,sizeof( aui1_cmd_buf));
                      UartCmd_Send("\r\n<<<\r\n",sizeof("\r\n<<<\r\n"));
                      #endif /*debug*/  
 453   4      
 454   4              //need to manual reset the buffer data , prevent buffer overflow
 455   4              memset( aui1_cmd_buf,0,sizeof( aui1_cmd_buf));  
 456   4              u8UartRxCnt = 0;
 457   4              u8SetProcessPkt = 0;  
 458   4            }
 459   3          }
 460   2        }
 461   1      
 462   1        //make sure clear RX flag 
 463   1      }
 464          
 465          
 466          void SystemClkDelay(uint16_t Delay)
 467          {
 468   1        while(Delay--);
 469   1      }
 470          
 471          void UartCmd_Send(uint8_t *pui1_data ,uint8_t z_len )
 472          {
 473   1          uint8_t i;
 474   1      
 475   1        DISABLE_UART0_INTERRUPT;
 476   1      
C51 COMPILER V9.55   UART_COMMAND                                                          05/07/2019 19:56:58 PAGE 9   

 477   1        for (i=0 ;i<z_len;i++)
 478   1        {
 479   2          SystemClkDelay(0x40);
 480   2          UART_Send_Data(UART0 , (uint8_t)*(pui1_data+i));
 481   2        }
 482   1      
 483   1        ENABLE_UART0_INTERRUPT;
 484   1      }
 485          
 486          // TODO: Step #6 , add UART0_Process to while loop
 487          void UART0_Process(void)
 488          {
 489   1        if(u8SetProcessPkt)
 490   1        {
 491   2          u8SetProcessPkt=0;
 492   2      
 493   2          _UartCmdParser_Parse_cmd();
 494   2      
 495   2          #if 0 //debug
                  UartCmd_Send(aui1_cmd_buf,sizeof( aui1_cmd_buf));
                  #endif
 498   2      
 499   2          //reset buffer after cmd process
 500   2          memset( aui1_cmd_buf,0,sizeof( aui1_cmd_buf));      
 501   2        }
 502   1      }
 503          
 504          
 505          
 506          
 507          
 508          
 509          
 510          
 511          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1465    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     62      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
